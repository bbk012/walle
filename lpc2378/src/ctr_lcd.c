//  **************************************************************************************************************
//   						      ctr_lcd.c
// 
//		Nokia 6610 LCD Display Driver  (Epson S1D15G00 Controller)
//
//		Controller used for LCD Display is a Epson S1D15G00 driver	                                                                     
//		Note: For Olimex SAM7-EX256 boards with the G8 decal or the Sparkfun Color LCD 128x128 Nokia Knock-Off
//
//
//		We will use a 132 x 132 pixel matrix - each pixel has 12 bits of color information.	
//      IMPORTANT! (By B.K.):
//      1. On my display direction is as on picture below (different to original James P Lynch implementation)
//      2. Following are limits (last visible pixels)  0 <= x <= 129, 0 <= y <= 129 when below corrections
//         are implemented
//      3. Because of prblems of displaying fonts from last font byte to the first I changed setup of the
//         display to render font starting from its first byte to the last.
//      4. I noticed that for this setup when LCD command PASET is executed to get right position of pixel
//         on the display x coordinate for that command needs to be increased by 2 i.e. x=x+2 and I changed
//         all used functions accordingly.
//
//
//                        ------------Y-------------->                            
//                                           |   |
//				 		  ___________________|___|___
//						  |  ======================  |
//	   			   (0,0)  |--------------------------|(0,129)                                                                  
//              |         |                          |      
//              |         |                          |      
//              |         |                          |      
//              |         |                          |      
//              |         |                          |      
//              |     Rows|    Nokia 6610 Display    |      Note: In general, you can't view column 130 or column 131
//              |         |                          |                                         
//              X         |                          |      
//              |         |                          |      
//              |         |                          |      
//              |         |                          |      
//              |         |                          |      
//              |         |                          |      
//				v   	  |--------------------------|
//	                    (129,0)      Columns         (129,129)
//                              
//                            
//                      
//	                                                                     
//				132 x 132 pixel matrix has two methods to specify the color info
//                           
//				1. 	12 bits per pixel	                                                                     
//                 	requires command and 1.5 data bytes to specify a single pixel 
//					(3 data bytes can specify 2 pixels)          
//
//				2. 8 bits per pixel
//					requires one command and one data byte to specify the single pixel	                                                                     
//                  note: pixel data byte converted by RGB table to 12-bit format above         
//
//				THIS IMPLEMENTATION USES THE 12 BITS PER PIXEL METHOD!
//											 -------------------------
//
// IMPORTANT! 
// Original James P Lynch file for SAM7-EX256 was modified to support Olimex LPC2378 STK
// Author: Bogdan Kowalczyk May 30, 2008
//                            
//	HARDWARE INTERFACE
//  ------------------
//	                                                                     
//	The Nokia 6610 display uses a SPI serial interface (9 bits) through SSP0 port of LPC2378 uP                           
//
//		P3.25  = LCD Reset (set to low to reset)
//		P1.21  = SSEL0 - LCD chip select (set to low to select the LCD chip)                                                              
//		P1.23  = MISO0 - Master In - Slave Out (reads data send out in this port not used)
//		P1.24  = MOSI0 - Master Out - Slave In pin (Serial Data to LCD slave)
//		P1.20  = SCK0  - Serial Clock (to LCD slave)
//      P1.26  = LCD_BL- Backlight PWM but set HIGH means full on                                               
//	                                                                     
//      The important thing to note is that you CANNOT read from the LCD!                      
//
//
//  Author:  James P Lynch  August 30, 2007
//  *************************************************************************************************************** 


// **************************************
//  Include Files 
// **************************************
#include "hw_lpc23xx.h"
#include "hw_spi.h"
#include "ctr_lcd.h"
#include "lib_error.h"
#include "lib_std.h"

//#include "lib_bmp.h"


//  *********************************************************************************
// 
//		Font tables for Nokia 6610 LCD Display Driver  (S1D15G00 Controller)
//
//		FONT6x8		-  SMALL font (mostly 5x7)
//		FONT8x8		-  MEDIUM font (8x8 characters, a bit thicker)
//		FONT8x16	-  LARGE font  (8x16 characters, thicker)
//	                                                                     
//		Note: ASCII characters 0x00 through 0x1F are not included in these fonts.                            
//
//  Author:  Jim Parise, James P Lynch  August 30, 2007
//  ********************************************************************************* 
const unsigned char FONT6x8[97][8] = 
{
{0x06,0x08,0x08,0x00,0x00,0x00,0x00,0x00},	//  columns, rows, num_bytes_per_char
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	space	0x20
{0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00},	//	!
{0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00},	//	"
{0x50,0x50,0xF8,0x50,0xF8,0x50,0x50,0x00},	//	#	
{0x20,0x78,0xA0,0x70,0x28,0xF0,0x20,0x00},	//	$
{0xC0,0xC8,0x10,0x20,0x40,0x98,0x18,0x00},	//	%
{0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,0x00},	//	&
{0x30,0x30,0x20,0x40,0x00,0x00,0x00,0x00},	//	'
{0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00},	//	(
{0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00},	//	)
{0x00,0x20,0xA8,0x70,0x70,0xA8,0x20,0x00},	//	*
{0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00},	//	+
{0x00,0x00,0x00,0x00,0x30,0x30,0x20,0x40},	//	,
{0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00},	//	-
{0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00},	//	.
{0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00},	//	/ (forward slash)
{0x70,0x88,0x88,0xA8,0x88,0x88,0x70,0x00},	//	0		0x30
{0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00},	//	1
{0x70,0x88,0x08,0x70,0x80,0x80,0xF8,0x00},	//	2
{0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x00},	//	3
{0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00},	//	4
{0xF8,0x80,0xF0,0x08,0x08,0x88,0x70,0x00},	//	5
{0x38,0x40,0x80,0xF0,0x88,0x88,0x70,0x00},	//	6
{0xF8,0x08,0x08,0x10,0x20,0x40,0x80,0x00},	//	7
{0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00},	//	8
{0x70,0x88,0x88,0x78,0x08,0x10,0xE0,0x00},	//	9
{0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x00},	//	:
{0x00,0x00,0x20,0x00,0x20,0x20,0x40,0x00},	//	;
{0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00},	//	<
{0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00},	//	=
{0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00},	//	>
{0x70,0x88,0x08,0x30,0x20,0x00,0x20,0x00},	//	?
{0x70,0x88,0xA8,0xB8,0xB0,0x80,0x78,0x00},	//	@		0x40
{0x20,0x50,0x88,0x88,0xF8,0x88,0x88,0x00},	//	A
{0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00},	//	B
{0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00},	//	C
{0xF0,0x88,0x88,0x88,0x88,0x88,0xF0,0x00},	//	D
{0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x00},	//	E
{0xF8,0x80,0x80,0xF0,0x80,0x80,0x80,0x00},	//	F
{0x78,0x88,0x80,0x80,0x98,0x88,0x78,0x00},	//	G
{0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00},	//	H
{0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00},	//	I
{0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x00},	//	J
{0x88,0x90,0xA0,0xC0,0xA0,0x90,0x88,0x00},	//	K
{0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00},	//	L
{0x88,0xD8,0xA8,0xA8,0xA8,0x88,0x88,0x00},	//	M
{0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00},	//	N
{0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00},	//	O
{0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00},	//	P		0x50
{0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00},	//	Q
{0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00},	//	R
{0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00},	//	S
{0xF8,0xA8,0x20,0x20,0x20,0x20,0x20,0x00},	//	T
{0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00},	//	U
{0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00},	//	V
{0x88,0x88,0x88,0xA8,0xA8,0xA8,0x50,0x00},	//	W
{0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00},	//	X
{0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00},	//	Y
{0xF8,0x08,0x10,0x70,0x40,0x80,0xF8,0x00},	//	Z
{0x78,0x40,0x40,0x40,0x40,0x40,0x78,0x00},	//	[
{0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00},	//	\  (back slash)
{0x78,0x08,0x08,0x08,0x08,0x08,0x78,0x00},	//	]	
{0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00},	//	^
{0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00},	//	_
{0x60,0x60,0x20,0x10,0x00,0x00,0x00,0x00},	//	`		0x60
{0x00,0x00,0x60,0x10,0x70,0x90,0x78,0x00},	//	a
{0x80,0x80,0xB0,0xC8,0x88,0xC8,0xB0,0x00},	//	b
{0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x00},	//	c
{0x08,0x08,0x68,0x98,0x88,0x98,0x68,0x00},	//	d
{0x00,0x00,0x70,0x88,0xF8,0x80,0x70,0x00},	//	e
{0x10,0x28,0x20,0x70,0x20,0x20,0x20,0x00},	//	f
{0x00,0x00,0x70,0x98,0x98,0x68,0x08,0x70},	//	g
{0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x00},	//	h
{0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00},	//	i
{0x10,0x00,0x10,0x10,0x10,0x90,0x60,0x00},	//	j
{0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00},	//	k
{0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00},	//	l
{0x00,0x00,0xD0,0xA8,0xA8,0xA8,0xA8,0x00},	//	m
{0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00},	//	n
{0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00},	//	o
{0x00,0x00,0xB0,0xC8,0xC8,0xB0,0x80,0x80},	//	p		0x70
{0x00,0x00,0x68,0x98,0x98,0x68,0x08,0x08},	//	q
{0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00},	//	r
{0x00,0x00,0x78,0x80,0x70,0x08,0xF0,0x00},	//	s
{0x20,0x20,0xF8,0x20,0x20,0x28,0x10,0x00},	//	t
{0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00},	//	u
{0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00},	//	v
{0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00},	//	w
{0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00},	//	x
{0x00,0x00,0x88,0x88,0x78,0x08,0x88,0x70},	//	y
{0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00},	//	z
{0x10,0x20,0x20,0x40,0x20,0x20,0x10,0x00},	//	{
{0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00},	//	|
{0x40,0x20,0x20,0x10,0x20,0x20,0x40,0x00},	//	}
{0x40,0xA8,0x10,0x00,0x00,0x00,0x00,0x00},	//	~
{0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00}	//	DEL
};	



const unsigned char FONT8x8[97][8] = 
{
{0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00},	//  columns, rows, num_bytes_per_char
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	space	0x20
{0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00},	//	!
{0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00},	//	"
{0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00},	//	#	
{0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00},	//	$
{0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00},	//	%
{0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00},	//	&
{0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00},	//	'
{0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00},	//	(
{0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00},	//	)
{0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00},	//	*
{0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00},	//	+
{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30},	//	,
{0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00},	//	-
{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00},	//	.
{0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00},	//	/ (forward slash)
{0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00},	//	0		0x30
{0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00},	//	1
{0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00},	//	2
{0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},	//	3
{0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00},	//	4
{0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},	//	5
{0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00},	//	6
{0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00},	//	7
{0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},	//	8
{0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00},	//	9
{0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00},	//	:
{0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30},	//	;
{0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00},	//	<
{0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00},	//	=
{0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00},	//	>
{0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00},	//	?
{0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00},	//	@		0x40
{0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00},	//	A
{0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00},	//	B
{0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00},	//	C
{0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00},	//	D
{0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00},	//	E
{0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00},	//	F
{0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00},	//	G
{0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00},	//	H
{0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},	//	I
{0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00},	//	J
{0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00},	//	K
{0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00},	//	L
{0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00},	//	M
{0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00},	//	N
{0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00},	//	O
{0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00},	//	P		0x50
{0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00},	//	Q
{0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00},	//	R
{0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00},	//	S
{0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00},	//	T
{0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00},	//	U
{0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},	//	V
{0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},	//	W
{0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00},	//	X
{0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00},	//	Y
{0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00},	//	Z
{0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00},	//	[
{0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00},	//	\  (back slash)
{0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00},	//	]	
{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00},	//	^
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},	//	_
{0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00},	//	`		0x60
{0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00},	//	a
{0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00},	//	b
{0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00},	//	c
{0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00},	//	d
{0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00},	//	e
{0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00},	//	f
{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C},	//	g
{0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00},	//	h
{0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},	//	i
{0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C},	//	j
{0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00},	//	k
{0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},	//	l
{0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00},	//	m
{0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00},	//	n
{0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00},	//	o
{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78},	//	p		0x70
{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F},	//	q
{0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00},	//	r
{0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00},	//	s
{0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00},	//	t
{0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00},	//	u
{0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00},	//	v
{0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00},	//	w
{0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00},	//	x
{0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C},	//	y
{0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00},	//	z
{0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00},	//	{
{0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00},	//	|
{0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00},	//	}
{0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00},	//	~
{0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00}   //	DEL 
};

											


const unsigned char FONT8x16[97][16] = 
{
{0x08,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//  columns, rows, num_bytes_per_char
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	space	0x20
{0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},	//	!
{0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	"
{0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00},	//	#	
{0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00},	//	$
{0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00},	//	%
{0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00},	//	&
{0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'
{0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00},	//	(
{0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00},	//	)
{0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00},	//	*
{0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},	//	+
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00},	//	,
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	-
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},	//	.
{0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00},	//	/ (forward slash)
{0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00},	//	0		0x30
{0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00},	//	1
{0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00},	//	2
{0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00},	//	3
{0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00},	//	4
{0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00},	//	5
{0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00},	//	6
{0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00},	//	7
{0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00},	//	8
{0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00},	//	9
{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},	//	:
{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00},	//	;
{0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00},	//	<
{0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00},	//	=
{0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00},	//	>
{0x00,0x00,0x3E,0x63,0x63,0x06,0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00},	//	?
{0x00,0x00,0x3E,0x63,0x63,0x6F,0x6B,0x6B,0x6E,0x60,0x60,0x3E,0x00,0x00,0x00,0x00},	//	@		0x40
{0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00},	//	A
{0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00},	//	B
{0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00},	//	C
{0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00},	//	D
{0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00},	//	E
{0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00},	//	F
{0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x6F,0x63,0x63,0x37,0x1D,0x00,0x00,0x00,0x00},	//	G
{0x00,0x00,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00},	//	H
{0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},	//	I
{0x00,0x00,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},	//	J
{0x00,0x00,0x73,0x33,0x36,0x36,0x3C,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00},	//	K
{0x00,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00},	//	L
{0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00},	//	M
{0x00,0x00,0x63,0x63,0x73,0x7B,0x7F,0x6F,0x67,0x63,0x63,0x63,0x00,0x00,0x00,0x00},	//	N
{0x00,0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00,0x00,0x00},	//	O
{0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00},	//	P		0x50
{0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x06,0x07,0x00,0x00},	//	Q
{0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00},	//	R
{0x00,0x00,0x3E,0x63,0x63,0x30,0x1C,0x06,0x03,0x63,0x63,0x3E,0x00,0x00,0x00,0x00},	//	S
{0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},	//	T
{0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00},	//	U
{0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x08,0x00,0x00,0x00,0x00},	//	V
{0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x36,0x00,0x00,0x00,0x00},	//	W
{0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x3C,0x66,0xC3,0xC3,0x00,0x00,0x00,0x00},	//	X
{0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},	//	Y
{0x00,0x00,0x7F,0x63,0x43,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00},	//	Z
{0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00},	//	[
{0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00},	//	\  (back slash)
{0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00},	//	]	
{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	^
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},	//	_
{0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	`		0x60
{0x00,0x00,0x00,0x00,0x00,0x3C,0x46,0x06,0x3E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00},	//	a
{0x00,0x00,0x70,0x30,0x30,0x3C,0x36,0x33,0x33,0x33,0x33,0x6E,0x00,0x00,0x00,0x00},	//	b
{0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x60,0x60,0x60,0x63,0x3E,0x00,0x00,0x00,0x00},	//	c
{0x00,0x00,0x0E,0x06,0x06,0x1E,0x36,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00},	//	d
{0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x7E,0x60,0x63,0x3E,0x00,0x00,0x00,0x00},	//	e
{0x00,0x00,0x1C,0x36,0x32,0x30,0x7C,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00},	//	f
{0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00},	//	g
{0x00,0x00,0x70,0x30,0x30,0x36,0x3B,0x33,0x33,0x33,0x33,0x73,0x00,0x00,0x00,0x00},	//	h
{0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00},	//	i
{0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00},	//	j
{0x00,0x00,0x70,0x30,0x30,0x33,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,0x00,0x00,0x00},	//	k
{0x00,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00},	//	l
{0x00,0x00,0x00,0x00,0x00,0x6E,0x7F,0x6B,0x6B,0x6B,0x6B,0x6B,0x00,0x00,0x00,0x00},	//	m
{0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x00},	//	n
{0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00},	//	o
{0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,0x00},	//	p		0x70
{0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00,0x00},	//	q
{0x00,0x00,0x00,0x00,0x00,0x6E,0x3B,0x33,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00},	//	r
{0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x38,0x0E,0x03,0x63,0x3E,0x00,0x00,0x00,0x00},	//	s
{0x00,0x00,0x08,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x1B,0x0E,0x00,0x00,0x00,0x00},	//	t
{0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00},	//	u
{0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00},	//	v
{0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00},	//	w
{0x00,0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x00,0x00,0x00,0x00},	//	x
{0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x06,0x3C,0x00,0x00},	//	y
{0x00,0x00,0x00,0x00,0x00,0x7F,0x66,0x0C,0x18,0x30,0x63,0x7F,0x00,0x00,0x00,0x00},	//	z
{0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00},	//	{
{0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00},	//	|
{0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00},	//	}
{0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	~
{0x00,0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}   //	DEL
};	





//  *****************************************************************************
//   						Backlight
// 
//     Turns the backlight on and off
//     
//	   Inputs:	state  -  1 = backlight on
//						  2 = backlight off
//						                                              
//
//  Author:  Olimex, James P Lynch     August 30, 2007
//  IMPORTANT! 
//  Original James P Lynch file for SAM7-EX256 was modified to support Olimex LPC2378 STK
//  ***************************************************************************** 
void Backlight(unsigned char state) {

  if(state == 1)
	FIO1SET = BIT26; //set P1.26 HIGH should turn on LCD
  else
	FIO1CLR = BIT26; //set P1.26 LOW should turn off LCD
}//Backlight


//  *****************************************************************************
//   						InitLcd.c
// 
//     Initializes the Epson S1D15G00 LCD Controller
//     
//	   Inputs:	none
//
//  	Author:  James P Lynch     August 30, 2007
//  ***************************************************************************** 
void InitLcd(void) {
	
	// Hardware reset
	LCD_RESET_LOW;
	LCDDelay(10000);
	LCD_RESET_HIGH;
	LCDDelay(10000);

	// Display control
	WriteSpiCommand(DISCTL);
	WriteSpiData(0x00); // P1: 0x00 = 2 divisions, switching period=8 (default)
	WriteSpiData(0x20); // P2: 0x20 = nlines/4 - 1 = 132/4 - 1 = 32)
	WriteSpiData(0x00); // P3: 0x00 = no inversely highlighted lines

	// COM scan
	WriteSpiCommand(COMSCN);
	WriteSpiData(1);  	// P1: 0x01 = Scan 1->80, 160<-81

	// Internal oscilator ON
	WriteSpiCommand(OSCON);

	// Sleep out
	WriteSpiCommand(SLPOUT);

	// Power control
	WriteSpiCommand(PWRCTR);
	WriteSpiData(0x0f);   // reference voltage regulator on, circuit voltage follower on, BOOST ON

	// Inverse display
	WriteSpiCommand(DISINV);

	// Data control
	WriteSpiCommand(DATCTL);
//B.K. Original inverted page address setup changed to normal because of problewm with wrap-around feature of the LCD in inverted mode	
//	WriteSpiData(0x01); // P1: 0x01 = page address inverted, column address normal, address scan in column direction
	WriteSpiData(0x00); // P1: 0x00 = page address normal, column address normal, address scan in column direction
	WriteSpiData(0x00); // P2: 0x00 = RGB sequence (default value)
	WriteSpiData(0x02); // P3: 0x02 = Grayscale -> 16 (selects 12-bit color, type A)

	// Voltage control (contrast setting)
	WriteSpiCommand(VOLCTR);
	WriteSpiData(32);	// P1 = 32  volume value (experiment with this value to get the best contrast)
	WriteSpiData(3);	// P2 = 3   resistance ratio (only value that works)

	// allow power supply to stabilize
	LCDDelay(100000);

	// turn on the display
	WriteSpiCommand(DISON);	
}//InitLcd


//  *************************************************************************************
//   						LCDWriteBmp
// 
//	Place bitmap (12 bits per pixel) at specified location on the LCD 
//     
//	Inputs:	  x0     =   row address (bitmap top left corner)
//			  y0     =   column address (bitmap top left corner)
//			  bmp    =   pointer to bitmap data (generated by BmpToArray tool)
//		  
//  IMPORTANT! Assumes that first byte of bmp is width while second byte of bmp is hight (in pixel)
//             of the displayed bitmap.
//	Returns:   nothing  
//
//
//  *************************************************************************************  
void LCDWriteBmp(int x, int y, const unsigned char* bmp) {
	
	long			j;			// loop counter
	
	// Column address set  (command 0x2A)
	WriteSpiCommand(CASET);
	WriteSpiData(y);
	WriteSpiData(y+bmp[0]-1);//B.K. get bmp width data

	// Page address set  (command 0x2B)
	WriteSpiCommand(PASET);
	WriteSpiData(x+2);
	WriteSpiData(x+1+bmp[1]);//B.K. get bmp hight data
  
	// WRITE MEMORY
	WriteSpiCommand(RAMWR);

	for(j = 0; j < ((bmp[0]*bmp[1])*3)/2; j++) {
		WriteSpiData(bmp[j+2]);
	}
}//LCDWriteBmp


//  *************************************************************************************
//   						LcdGetBmpWidth
// 
//	Returnes width of the specified bitmap 
//     
//	Inputs:	  pointer to bitmap
//		  
//  IMPORTANT! Assumes that first byte of bmp is width while second byte of bmp is hight (in pixel)
//             of the displayed bitmap.
//	Returns:   Width of the bitmap in pixels 
//
//
//  *************************************************************************************  
int LCDGetBmpWidth(const unsigned char* bmp)
{
	return bmp[0];//get width of the bmp and return it
}//LcdGetBmpWidth 

//  *************************************************************************************
//   						LcdGetBmpHight
// 
//	Return bitmap height 
//     
//	Inputs:	  pointer to bitmap
//		  
//  IMPORTANT! Assumes that first byte of bmp is width while second byte of bmp is hight (in pixel)
//             of the displayed bitmap.
//	Returns:   Height of the bitmap in pixels 
//
//
//  *************************************************************************************  
int LCDGetBmpHight(const unsigned char* bmp)
{
	return bmp[1];//get width of the bmp and return it
}//LcdGetBmpHight 


//  *****************************************************************************
//   						LCDClearScreen.c
// 
//     Clears the LCD screen to single color (BLACK)
//     
//	   Inputs:	none
//
//  	Author:  James P Lynch     August 30, 2007
//  ***************************************************************************** 
void LCDClearScreen(void) {
	
	long	i;			// loop counter

	// Row address set  (command 0x2B)
	WriteSpiCommand(PASET);
	WriteSpiData(0);
	WriteSpiData(131);

	// Column address set  (command 0x2A)
	WriteSpiCommand(CASET);
	WriteSpiData(0);
	WriteSpiData(131);

	// set the display memory to BLACK
	WriteSpiCommand(RAMWR);
	for(i = 0; i < ((131 * 131) / 2); i++) {
			WriteSpiData((BLACK >> 4) & 0xFF);
			WriteSpiData(((BLACK & 0xF) << 4) | ((BLACK >> 8) & 0xF));
			WriteSpiData(BLACK & 0xFF);
	}
}


//  *************************************************************************************
//   						LCDSetPixel.c
// 
//	Lights a single pixel in the specified color at the specified x and y addresses
//     
//	Inputs:	  x     =   row address (0 .. 131)
//			  y     =   column address  (0 .. 131)
//		      color = 	12-bit color value  rrrrggggbbbb
//						rrrr = 1111 full red
//								  :
//						       0000 red is off
//
//						gggg = 1111 full green
//								  :
//						       0000 green is off
//
//						bbbb = 1111 full blue
//								  :
//						       0000 blue is off
//
//	   Returns:   nothing 
//
//		Note: see lcd.h for some sample color settings 
//
//  	Author:  James P Lynch     August 30, 2007
//  ************************************************************************************* 
void LCDSetPixel(int  x, int  y, int  color) {

	// Row address set  (command 0x2B)
	WriteSpiCommand(PASET);
	//B.K. I do not know why but below correction is required to have pixel correctly placed on LCD
	WriteSpiData(x+2);
	WriteSpiData(x+2);

	// Column address set  (command 0x2A)
	WriteSpiCommand(CASET);
	WriteSpiData(y);
	WriteSpiData(y);
	
	// Now illuminate the pixel (2nd pixel will be ignored)
	WriteSpiCommand(RAMWR);
	WriteSpiData((color >> 4) & 0xFF);
	WriteSpiData(((color & 0xF) << 4) | ((color >> 8) & 0xF));
	WriteSpiData(color & 0xFF);
}


//  *************************************************************************************************
//   						LCDSetLine.c
// 
//	Draws a line in the specified color from (x0,y0) to (x1,y1) 
//     
//	Inputs:	  x     =   row address (0 .. 131)
//			  y     =   column address  (0 .. 131)
//		      color = 	12-bit color value  rrrrggggbbbb
//						rrrr = 1111 full red
//								  :
//						       0000 red is off
//
//						gggg = 1111 full green
//								  :
//						       0000 green is off
//
//						bbbb = 1111 full blue
//								  :
//						       0000 blue is off
//
//	Returns:   nothing 
//
//	Note: good write-up on this algorithm in Wikipedia (search for Bresenham's line algorithm)
//		  see lcd.h for some sample color settings  
//
//	Authors: 	Dr. Leonard McMillan, Associate Professor UNC
//				Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
//
//				Note: taken verbatim from Professor McMillan's presentation: 
//					  http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
//
//  ************************************************************************************************* 
void LCDSetLine(int x0, int y0, int x1, int y1, int color) {

        int dy = y1 - y0;
        int dx = x1 - x0;
        int stepx, stepy;

        if (dy < 0) { dy = -dy;  stepy = -1; } else { stepy = 1; }
        if (dx < 0) { dx = -dx;  stepx = -1; } else { stepx = 1; }
        dy <<= 1;							// dy is now 2*dy
        dx <<= 1;							// dx is now 2*dx

		LCDSetPixel(x0, y0, color);
        if (dx > dy) {
            int fraction = dy - (dx >> 1);	// same as 2*dy - dx
            while (x0 != x1) {
                if (fraction >= 0) {
                    y0 += stepy;
                    fraction -= dx;			// same as fraction -= 2*dx
                }
                x0 += stepx;
                fraction += dy;				// same as fraction -= 2*dy
                LCDSetPixel(x0, y0, color);
            }
        } else {
            int fraction = dx - (dy >> 1);
            while (y0 != y1) {
                if (fraction >= 0) {
                    x0 += stepx;
                    fraction -= dy;
                }
                y0 += stepy;
                fraction += dx;
                LCDSetPixel(x0, y0, color);
            }
        }
}


//  *****************************************************************************************
//   						LCDSetRect.c
// 
//	Draws a rectangle in the specified color from (x1,y1) to (x2,y2)
//	Rectangle can be filled with a color if desired 
//     
//	Inputs:	  x     =   row address (0 .. 131)
//			  y     =   column address  (0 .. 131)
//			  fill  =   0=no fill, 1-fill entire rectangle 
//		      color = 	12-bit color value for lines	rrrrggggbbbb
//						rrrr = 1111 full red
//								  :
//						       0000 red is off
//
//						gggg = 1111 full green
//								  :
//						       0000 green is off
//
//						bbbb = 1111 full blue
//								  :
//						       0000 blue is off
//
//	   Returns:   nothing 
//
//		Notes:
//
//		The best way to fill a rectangle is to take advantage of the "wrap-around" featute
//		built into the Epson S1D15G00 controller. By defining a drawing box, the memory can
//		be simply filled by successive memory writes until all pixels have been illuminated.
//
//			1.  Given the coordinates of two opposing corners (x0, y0) (x1, y1)
//				calculate the minimums and maximums of the coordinates
//
//					xmin = (x0 <= x1) ? x0 : x1;
//					xmax = (x0 > x1) ? x0 : x1;
//					ymin = (y0 <= y1) ? y0 : y1;
//					ymax = (y0 > y1) ? y0 : y1;
//
//			2. Now set up the drawing box to be the desired rectangle
//
//					WriteSpiCommand(PASET);		// set the row boundaries
//					WriteSpiData(xmin);
//					WriteSpiData(xmax);
//					WriteSpiCommand(CASET);		// set the column boundaries
//					WriteSpiData(ymin);
//					WriteSpiData(ymax);
//
//			3. Calculate the number of pixels to be written divided by 2
//
//					NumPixels = ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1)
//
//						You may notice that I added one pixel to the formula. 
//						This covers the case where the number of pixels is odd and we 
//						would lose one pixel due to rounding error. In the case of
//						odd pixels, the number of pixels is exact. 
//						in the case of even pixels, we have one more pixel than
//						needed, but it cannot be displayed because it is outside
//						the drawing box.
//
//						We divide by 2 because two pixels are represented by three bytes.
//						So we work through the rectangle two pixels at a time.
//
//			4.  Now a simple memory write loop will fill the rectangle
//
//				for (i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1); i++) {
//					WriteSpiData((color >> 4) & 0xFF);
//					WriteSpiData(((color & 0xF) << 4) | ((color >> 8) & 0xF));
//					WriteSpiData(color & 0xFF);
//				}
//
//
//		In the case of an unfilled rectangle, drawing four lines with the Bresenham line
//		drawing algorithm is reasonably efficient.
//
//
//  	Author:  James P Lynch      August 30, 2007
//  ***************************************************************************************** 

void LCDSetRect(int x0, int y0, int x1, int y1, unsigned char fill, int color) {
	int 	xmin, xmax, ymin, ymax;
	int		i;
	
	// check if the rectangle is to be filled
	if (fill == FILL) {
		
		// best way to create a filled rectangle is to define a drawing box
		// and loop two pixels at a time
		
		// calculate the min and max for x and y directions
		xmin = (x0 <= x1) ? x0 : x1;
		xmax = (x0 > x1) ? x0 : x1;
		ymin = (y0 <= y1) ? y0 : y1;
		ymax = (y0 > y1) ? y0 : y1;
		
		// specify the controller drawing box according to those limits
		// Row address set  (command 0x2B)
		WriteSpiCommand(PASET);
		//B.K. I do not know why but to get pixel displayed correctly I need add 2 to x
		WriteSpiData(xmin+2);
		WriteSpiData(xmax+2);
		
		// Column address set  (command 0x2A)
		WriteSpiCommand(CASET);
		WriteSpiData(ymin);
		WriteSpiData(ymax);
		
		// WRITE MEMORY
		WriteSpiCommand(RAMWR);
		
		// loop on total number of pixels / 2
		for (i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 130); i++) {
			
			// use the color value to output three data bytes covering two pixels
			WriteSpiData((color >> 4) & 0xFF);
			WriteSpiData(((color & 0xF) << 4) | ((color >> 8) & 0xF));
			WriteSpiData(color & 0xFF);
		}

	} else {
   	
   		// best way to draw un unfilled rectangle is to draw four lines
		LCDSetLine(x0, y0, x1, y0, color);
		LCDSetLine(x0, y1, x1, y1, color);
		LCDSetLine(x0, y0, x0, y1, color);
		LCDSetLine(x1, y0, x1, y1, color);
    }
}



//  *************************************************************************************
//   						LCDSetCircle.c
// 
//	Draws a line in the specified color at center (x0,y0) with radius 
//     
//	Inputs:	  x0     =   row address (0 .. 131)
//			  y0     =   column address  (0 .. 131)
//			  radius =  radius in pixels
//		      color  = 	12-bit color value  rrrrggggbbbb
//
//	Returns:   nothing  
//
//	Author: 	Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
//
//				Note: taken verbatim Wikipedia article on Bresenham's line algorithm  
//					  http://www.wikipedia.org
//
//  ************************************************************************************* 

void LCDSetCircle(int x0, int y0, int radius, int color) {
	int f = 1 - radius;
	int ddF_x = 0;
	int ddF_y = -2 * radius;
	int x = 0;
	int y = radius;
 
	LCDSetPixel(x0, y0 + radius, color);
	LCDSetPixel(x0, y0 - radius, color);
	LCDSetPixel(x0 + radius, y0, color);
	LCDSetPixel(x0 - radius, y0, color);
 
	while(x < y) {
		if(f >= 0) {
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x + 1;    
		LCDSetPixel(x0 + x, y0 + y, color);
		LCDSetPixel(x0 - x, y0 + y, color);
		LCDSetPixel(x0 + x, y0 - y, color);
		LCDSetPixel(x0 - x, y0 - y, color);
		LCDSetPixel(x0 + y, y0 + x, color);
		LCDSetPixel(x0 - y, y0 + x, color);
		LCDSetPixel(x0 + y, y0 - x, color);
		LCDSetPixel(x0 - y, y0 - x, color);
	}
}

#if 0
//B.K. This was commented out because original function assumed to work for inverted page address mode.
//In this mode however wrap-around feature did not work correctly for this LCD and result was
//that small letters like "g" or "y" or "q" (which have data for the last byte <>0x00) were displayed wrong.
//
//  *****************************************************************************
//   						LCDPutChar.c
// 
//     Draws an ASCII character at the specified (x,y) address and color
//     
//	   Inputs:	  c       =   character to be displayed   	  
//				  x       =   row address (0 .. 131)
//				  y       =   column address  (0 .. 131)
//				  size    =   font pitch (SMALL, MEDIUM, LARGE)
//		          fcolor  =   12-bit foreground color value		rrrrggggbbbb
//		          bcolor  =   12-bit background color value		rrrrggggbbbb
//
//
//	   Returns:   nothing  
//
//  Notes:  Here's an example to display "E" at address (20,20)
//
//			LCDPutChar('E', 20, 20, MEDIUM, WHITE, BLACK);
//
//					 (27,20)        (27,27)
//						|             |
//						|             |
//				     ^	V             V
//				     :  _ # # # # # # #   0x7F
//				     :  _ _ # # _ _ _ #   0x31
//				     :  _ _ # # _ # _ _   0x34
//				     x  _ _ # # # # _ _   0x3C
//				     :  _ _ # # _ # _ _   0x34
//				     :  _ _ # # _ _ _ #   0x31
//				     :  _ # # # # # # #   0x7F
//				     :  _ _ _ _ _ _ _ _   0x00
//
//						------y----------->
//						^             ^
//						|             |
//						|             |
//					 (20,20)       (20,27)
//
//
//		The most efficient way to display a character is to make use of the "wrap-around" feature
//		of the Epson S1D16G00 LCD controller chip.	
//
//		Assume that we position the character at (20, 20)  that's a  (row, col) specification.
//		With the row and column address set commands, you can specify an 8x8 box for the SMALL and MEDIUM
//		characters or a 16x8 box for the LARGE characters.
//
//			WriteSpiCommand(PASET);		// set the row drawing limits
//			WriteSpiData(20);			//
//			WriteSpiData(27);			// limit rows to (20, 27)
// 
//			WriteSpiCommand(CASET);		// set the column drawing limits
//			WriteSpiData(20);			// 
//			WriteSpiData(27);			// limit columns to (20,27)
//
//		When the algorithm completes col 27, the column address wraps back to 20
//		At the same time, the row address increases by one (this is done by the controller)
//
//		We walk through each row, two pixels at a time. The purpose is to create three
//		data bytes representing these two pixels in the following format
//
//			Data for pixel 0:  RRRRGGGGBBBB
//			Data for Pixel 1:  RRRRGGGGBBBB
//
//			WriteSpiCommand(RAMWR);				// start a memory write (96 data bytes to follow)
//
//			WriteSpiData(RRRRGGGG);				// first pixel, red and green data
//			WriteSpiData(BBBBRRRR);				// first pixel, blue data; second pixel, red data
//			WriteSpiData(GGGGBBBB);				// second pixel, green and blue data
//				:
//    	and so on until all pixels displayed!
//				:
//			WriteSpiCommand(NOP);				// this will terminate the RAMWR command
//
//
//  	Author:  James P Lynch    August 30, 2007
//  ***************************************************************************** 
void LCDPutChar(char c, int  x, int  y, int size, int fColor, int bColor) {
	
//	extern const unsigned char FONT6x8[97][8];
//	extern const unsigned char FONT8x8[97][8];
//	extern const unsigned char FONT8x16[97][16];
		
	int					i,j;
	unsigned int		nCols;
	unsigned int		nRows;
	unsigned int		nBytes;
	unsigned char		PixelRow;
	unsigned char		Mask;
	unsigned int		Word0;
	unsigned int		Word1;
	unsigned char		*pFont;
	unsigned char		*pChar;
	unsigned char		*FontTable[] = {(unsigned char *)FONT6x8, (unsigned char *)FONT8x8, (unsigned char *)FONT8x16}; 
	
	// get pointer to the beginning of the selected font table
	pFont = (unsigned char *)FontTable[size];	
	
	// get the nColumns, nRows and nBytes
	nCols = *pFont;
	nRows = *(pFont + 1);
	nBytes = *(pFont + 2);

	// get pointer to the last byte of the desired character
	pChar = pFont + (nBytes * (c - 0x1F)) + nBytes - 1;
	
	// Row address set  (command 0x2B)
	WriteSpiCommand(PASET);
	WriteSpiData(x);
	WriteSpiData(x + nRows - 1);

	// Column address set  (command 0x2A)
	WriteSpiCommand(CASET);
	WriteSpiData(y);
	WriteSpiData(y + nCols - 1);
	
	// WRITE MEMORY
	WriteSpiCommand(RAMWR);

	// loop on each row, working backwards from the bottom to the top
	for (i = nRows - 1; i >= 0; i--) {
		
		// copy pixel row from font table and then decrement row
		PixelRow = *pChar--;
	
		// loop on each pixel in the row (left to right)
		// Note: we do two pixels each loop
		Mask = 0x80;
		for (j = 0; j < nCols; j += 2) {
		
			// if pixel bit set, use foreground color; else use the background color
			// now get the pixel color for two successive pixels
			if ((PixelRow & Mask) == 0)
				Word0 = bColor;
			else
				Word0 = fColor;
			Mask = Mask >> 1;
			if ((PixelRow & Mask) == 0)
				Word1 = bColor;
			else
				Word1 = fColor;
			Mask = Mask >> 1;
			
			// use this information to output three data bytes
			WriteSpiData((Word0 >> 4) & 0xFF);
			WriteSpiData(((Word0 & 0xF) << 4) | ((Word1 >> 8) & 0xF));
			WriteSpiData(Word1 & 0xFF);
		}	
	}
	// terminate the Write Memory command
	WriteSpiCommand(NOP);	
}
#endif //#if 0 original function commented out

//B.K. This function has same interface like the original one anyhow character data
//are displayed starting from first byte to the last one because page address inverted mode is not used
void LCDPutChar(char c, int  x, int  y, int size, int fColor, int bColor) 
{
	int					i,j;
	unsigned int		nCols;
	unsigned int		nRows;
	unsigned int		nBytes;
	unsigned char		PixelRow;
	unsigned char		Mask;
	unsigned int		Word0;
	unsigned int		Word1;
	unsigned char		*pFont;
	unsigned char		*pChar;
	unsigned char		*FontTable[] = {(unsigned char *)FONT6x8, (unsigned char *)FONT8x8, (unsigned char *)FONT8x16}; 
	//B.K. I do not know why but fonts starts to be displayed in first line for x = 2
	//so to keep consistency between font handling I have to add below line of code
	x=x+2;

	// get pointer to the beginning of the selected font table
	pFont = (unsigned char *)FontTable[size];	
	
	// get the nColumns, nRows and nBytes
	nCols = *pFont;
	nRows = *(pFont + 1);
	nBytes = *(pFont + 2);

	//get pointer to the last byte of the desired character
	//pChar = pFont + (nBytes * (c - 0x1F)) + nBytes - 1;
	
	//B.K. Instead of getting pointer to last byte we are getting pointer to the first byte
	pChar = pFont + (nBytes * (c - 0x1F));
	
	// Row address set  (command 0x2B)
	WriteSpiCommand(PASET);
	WriteSpiData(x);
	WriteSpiData(x + nRows - 1);

	// Column address set  (command 0x2A)
	WriteSpiCommand(CASET);
	WriteSpiData(y);
	WriteSpiData(y + nCols - 1);
	
	// WRITE MEMORY
	WriteSpiCommand(RAMWR);

	// loop on each row, working backwards from the bottom to the top
	for (i = nRows - 1; i >= 0; i--) {//B.K. rows are changed from last to the first one but bytes are taken
		//from the first one to the last one
		
		PixelRow = *pChar++;//take subsequent bytes which defines pixels from the first byte of the character to the last one
	
		// loop on each pixel in the row (left to right)
		// Note: we do two pixels each loop
		Mask = 0x80;
		for (j = 0; j < nCols; j += 2) {
		
			// if pixel bit set, use foreground color; else use the background color
			// now get the pixel color for two successive pixels
			if ((PixelRow & Mask) == 0)
				Word0 = bColor;
			else
				Word0 = fColor;
			Mask = Mask >> 1;
			if ((PixelRow & Mask) == 0)
				Word1 = bColor;
			else
				Word1 = fColor;
			Mask = Mask >> 1;
			
			// use this information to output three data bytes
			WriteSpiData((Word0 >> 4) & 0xFF);
			WriteSpiData(((Word0 & 0xF) << 4) | ((Word1 >> 8) & 0xF));
			WriteSpiData(Word1 & 0xFF);
		}	
	}
	// terminate the Write Memory command
	WriteSpiCommand(NOP);	
}//LCDPutChar


//  *************************************************************************************************
//   						LCDPutStr.c
// 
//     Draws a null-terminates character string at the specified (x,y) address, size and color
//     
//	   Inputs:	  pString =   pointer to character string to be displayed   	  
//				  x       =   row address (0 .. 131)
//				  y       =   column address  (0 .. 131)
//				  Size    =   font pitch (SMALL, MEDIUM, LARGE)
//		          fColor  =   12-bit foreground color value             rrrrggggbbbb
//		          bColor  =   12-bit background color value             rrrrggggbbbb
//
//
//	   Returns:   nothing  
//
//  Notes:  Here's an example to display "Hello World!" at address (20,20)
//
//			LCDPutChar("Hello World!", 20, 20, LARGE, WHITE, BLACK);
//
//
//  	Author:  James P Lynch    August 30, 2007
//  ************************************************************************************************* 
void LCDPutStr(char *pString, int  x, int  y, int Size, int fColor, int bColor) {
						
	// loop until null-terminator is seen
	while (*pString != 0x00) {

		// draw the character
		LCDPutChar(*pString++, x, y, Size, fColor, bColor);	

		// advance the y position
		if (Size == SMALL)
			y = y + 6;
		else if (Size == MEDIUM)
			y = y + 8;
		else
			y = y + 8;
		
		// bail out if y exceeds 131
		if (y > 131) break;
	}
}//LCDPutStr

//  *************************************************************************************************
//   						LCDClrStr
// 
//     Draws space instead of every character of the string at the specified (x,y) address, size and color
//     Used to clear string placed with LCDPutStr
//
//	   Inputs:	  pString =   pointer to character string to be cleared from LCD   	  
//				  x       =   row address (0 .. 131)
//				  y       =   column address  (0 .. 131)
//				  Size    =   font pitch (SMALL, MEDIUM, LARGE)
//		          fColor  =   12-bit foreground color value             rrrrggggbbbb
//		          bColor  =   12-bit background color value             rrrrggggbbbb
//
//
//	   Returns:   nothing  
//
//  ************************************************************************************************* 
void LCDClrStr(char *pString, int  x, int  y, int Size, int fColor, int bColor) {
						
	// loop until null-terminator is seen
	while (*pString != 0x00) {

		// draw the character
		LCDPutChar(' ', x, y, Size, fColor, bColor);	
		pString++;
		// advance the y position
		if (Size == SMALL)
			y = y + 6;
		else if (Size == MEDIUM)
			y = y + 8;
		else
			y = y + 8;
		
		// bail out if y exceeds 131
		if (y > 131) break;
	}
}//LCDClrStr

//  *****************************************************************************
//   						LCDDelay.c
// 
//		Simple for loop delay
//     
//		Inputs:	a  -  loop count
//
//		Author:  James P Lynch  August 30, 2007
//  ***************************************************************************** 
void LCDDelay (unsigned long a) { 
	while (--a!=0); 
}//LCDDelay


//B.K. added functions to integrate with Graphics Library
/*
*********************************************************************************************************
* Name:                                   LCDSizeToFont
* 
* Description: Convert font size into pointer to void which is adress of specified font table beginning
*  
*
* Arguments:   font size
*
* Returns:     address of the specified font table
*
* 			
* Note(s):     
* 
* *********************************************************************************************************
*/

void* LCDSizeToFont(int size)
{
	switch(size)
	{
	case SMALL:
		return (void*)FONT6x8;
	case MEDIUM:
		return (void*)FONT8x8;
	case LARGE:
		return (void*)FONT8x16;
	default:
		return (void*)FONT6x8;
	}//switch
}//LCDSizeToFont

/*
*********************************************************************************************************
* Name:                                   LCDFontToSize
* 
* Description: Convert font table address to its corresponding size constant (id)
*  
*
* Arguments:   font table address
*
* Returns:     font size id
*
* 			
* Note(s):     
* 
* *********************************************************************************************************
*/
int   LCDFontToSize(void* font)
{
	if(font==(void*)FONT6x8) 
		return SMALL;
	else if(font==(void*)FONT8x8) 
		return MEDIUM;
	else if(font==(void*)FONT8x16)
		return LARGE;
		
	return SMALL;//should never happen but for the case of wrong void* font return SMALL
}//LCDFontToSize

/*
*********************************************************************************************************
* Name:                                   LCDFontWidth
* 
* Description: Convert font table address to its corresponding size constant (id)
*  
*
* Arguments:   font table address
*
* Returns:     width for selected font
*
* 			
* Note(s):     
* 
* *********************************************************************************************************
*/
int   LCDFontWidth(void* font)
{
    switch (LCDFontToSize(font))
    {
    case SMALL:
    	return 6;
    case MEDIUM:
    	return 8;
    case LARGE:
    	return 8;
    default:
        return 6;
    }//switch	
}//LCDFontWidth

/*
*********************************************************************************************************
* Name:                                   LCDFontHight
* 
* Description: Convert font table address to its corresponding size constant (id)
*  
*
* Arguments:   font table address
*
* Returns:     hight for selected font
*
* 			
* Note(s):     
* 
* *********************************************************************************************************
*/
int   LCDFontHight(void* font)
{
    switch (LCDFontToSize(font))
    {
    case SMALL:
    case MEDIUM:
    default:
    	return 8;
    case LARGE:
    	return 16;
    }//switch
}//LCDFontHight

static char TempResultBuff[32];//temporary buffer place for ltoa convertion 

/*
*********************************************************************************************************
* Name:                                   LCDDebugMessage
* 
* Description: Displays DEBUG message plus Value on the cleared LCD and generates SWI to stop operation
*  
*
* Arguments:   
*				pMsgStr - message to display
* 				Value - value to display
* 				x - LCD x position for MSg
* 				y - LCD y position for Msg
* 				ClrScr <>0 - clear screen on entry
* 				GenExcept <>0 - generate exception
* Returns:     none
*
* 			
* Note(s):     
* 
* *********************************************************************************************************
*/
void LCDDebugMessage(char *pMsgStr,long Value,int  x, int  y, char ClrScr, char GenExcept)
{
	if(ClrScr)
		LCDClearScreen();//clear the screen	
	LCDPutStr(pMsgStr,x,y,SMALL,WHITE,BLACK);
	ltoa(Value,TempResultBuff,10);//change to string
	LCDPutStr(TempResultBuff,x,y+(LCDFontWidth(SMALL)*(1+strlength(pMsgStr))),SMALL,WHITE,BLACK);
	if(GenExcept)
		DEBUG_EXCEPTION;//SWI to stop operation efter debug message is displayed
}//LCDDebugMessage

